#include <stdio.h>
#include <stdlib.h>
#include <sys/statvfs.h>
#include <sys/types.h>
#include <errno.h>
#include <assert.h>
#include <time.h>
#include <string.h>
#include <unistd.h>

/*
 * struct statvfs {
 *  unsigned long  f_bsize;    / file system block size
 *  unsigned long  f_frsize;   / fragment size
 *  fsblkcnt_t     f_blocks;   / size of fs in f_frsize units
 *  fsblkcnt_t     f_bfree;    / # free blocks
 *  fsblkcnt_t     f_bavail;   / # free blocks for non-root
 *  fsfilcnt_t     f_files;    / # inodes
 *  fsfilcnt_t     f_ffree;    / # free inodes
 *  fsfilcnt_t     f_favail;   / # free inodes for non-root
 *  unsigned long  f_fsid;     / file system ID
 *  unsigned long  f_flag;     / mount flags
 *  unsigned long  f_namemax;  / maximum filename length
 * };
 */

/*
void echo_stat(struct statvfs *buff)
{
  fprintf (stderr, "Block Size  :%lu\n",buff->f_bsize );
  fprintf (stderr, "Fragm Size  :%lu\n",buff->f_frsize );
  fprintf (stderr, "Blocks      :%lu\n",buff->f_blocks );
  fprintf (stderr, "Free blocks :%lu\n",buff->f_bfree );
  fprintf (stderr, "Non root fb :%lu\n",buff->f_bavail );
  fprintf (stderr, "Inodes      :%lu\n",buff->f_files );
  fprintf (stderr, "Free Inodes :%lu\n",buff->f_ffree );
  fprintf (stderr, "Non root fi :%lu\n",buff->f_favail );
  fprintf (stderr, "FS Id       :%lu\n",buff->f_fsid );
  fprintf (stderr, "Mount flags :%lu\n",buff->f_flag );
  fprintf (stderr, "Max fn leng :%lu\n",buff->f_namemax );
}
*/

// Produces pseudo-random numbers from 0 to ULLONG_MAX
// by filling all bits of unsigned long long integer number
// with bits of several "small" integer numbers generated by rand()
// http://stackoverflow.com/questions/28115724/getting-big-random-numbers-in-c-c

unsigned long bigrand(unsigned long max) {
  FILE *rdp;

  unsigned long num;

  rdp = fopen("/dev/urandom", "rb");
  
  assert(rdp);
  assert(fread(&num, sizeof(num), 1, rdp) == 1);
  fclose(rdp);

  return num%max;
}

//http://stackoverflow.com/questions/111928/is-there-a-printf-converter-to-print-in-binary-format
const char *byte_to_binary(int x)
{
  static char b[9];
  b[0] = '\0';

  int z;
  for (z = 128; z > 0; z >>= 1)
  {
    strcat(b, ((x & z) == z) ? "1" : "0");
  }

  return b;
}

int main(int argc, char **argv) {

  if (argc != 2) {
    fprintf(stderr,"Please provide a device to damage\n");
    exit(1);
  }
  if ( access( argv[1], F_OK ) == -1 ) {
    fprintf(stderr,"%s does not exist\n",argv[1]);
    exit(1);
  }
  if ( access( argv[1], R_OK ) == -1 ) {
    fprintf(stderr,"Need read access to %s\n",argv[1]);
    exit(1);
  }
  if ( access( argv[1], W_OK ) == -1 ) {
    fprintf(stderr,"Need write acces to %s\n",argv[1]);
    exit(1);
  }
  
  struct statvfs * buff;
  extern int errno;

  if ( !(buff = (struct statvfs *) malloc(sizeof(struct statvfs))) ) {
    perror("Failed to allocate memory to buffer.");
    exit(1);
  }
  if (statvfs(argv[1],buff) < 0 ) {
    perror("statvfs() has failed.");
    exit(1);
  } else {
    time_t t;
    srand((unsigned) time(&t));
    unsigned long bytetorot = bigrand(buff->f_bsize*buff->f_blocks);
    int bittorot = rand()%8;
    
    FILE *fp;
    fp = fopen(argv[1],"rb");
    fseek(fp,bytetorot,SEEK_SET);
    char c = fgetc(fp);
    fclose(fp);
    char cp = c;
    // flip the bit
    cp ^= 1 << bittorot;
    fp = fopen(argv[1],"wb");
    fseek(fp,bytetorot,SEEK_SET);
    fputc(cp,fp);
    fclose(fp);
//    fprintf(stdout,"Changed byte %lu ( %s -> %s )\n", bytetorot, byte_to_binary(c), byte_to_binary(cp));

    fprintf(stdout,"Changed byte %lu\n",bytetorot);
/*    fprintf(stdout,"Block size   : %lu\n", buff->f_bsize);
    fprintf(stdout,"Block        : %lu\n", buff->f_blocks);
    fprintf(stdout,"Bytes        : %lu\n", buff->f_bsize*buff->f_blocks);
    fprintf(stdout,"Byte to rot  : %lu\n", bytetorot);
    fprintf(stdout,"Bit to rot   : %i\n", bittorot);
    fprintf(stdout,"Content pre  : %s\n",byte_to_binary(c));
    fprintf(stdout,"Content post : %s\n",byte_to_binary(cp)); */
  }
  free(buff);

  exit(EXIT_SUCCESS);
}
